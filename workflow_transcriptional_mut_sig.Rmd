---
title: "Transcriptional signatures for mutations"
author:
  - name: Dharmesh D Bhuva
    affiliation:
      - Bioinformatics Division, Walter and Eliza Hall Institute of Medical Research, Parkville, VIC 3052, Australia
      - School of Mathematics and Statistics, University of Melbourne, Parkville, VIC 3010, Australia
    email: bhuva.d@wehi.edu.au
  - name: Momeneh Foroutan
    affiliation:
      - Department of Clinical Pathology, The University of Melbourne Centre for Cancer Research, Victorian Comprehensive Cancer Centre, Melbourne, Victoria 3000, Australia
    email: momeneh.foroutan@unimelb.edu.au
  - name: Ruqian Lyu
    affiliation:
      - Bioinformatics Division, Walter and Eliza Hall Institute of Medical Research, Parkville, VIC 3052, Australia??
    email: ??
  - name: Joseph Cursons
    affiliation:
      - Bioinformatics Division, Walter and Eliza Hall Institute of Medical Research, Parkville, VIC 3052, Australia
      - Department of Medical Biology, University of Melbourne, Parkville, VIC 3010, Australia
    email: cursons.j@wehi.edu.au
  - name: Melissa J Davis
    affiliation:
      - Bioinformatics Division, Walter and Eliza Hall Institute of Medical Research, Parkville, VIC 3052, Australia
      - Department of Medical Biology, University of Melbourne, Parkville, VIC 3010, Australia
    email: davis.m@wehi.edu.au
date: "`r format(Sys.time(), '%d %b %Y')`"
output:
  # BiocWorkflowTools::f1000_article
  BiocStyle::html_document:
    toc_float: true
    fig_caption: true
    number_sections: true
bibliography: [bibliography.bib, packages.bib]
vignette: |
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
keywords: Please list up to eight keywords to help readers interested in your article find it more easily.
abstract: >
  Transcriptional signatures for mutations
---

**R version**: `r R.version.string`

**Bioconductor version**: `r BiocManager::version()`

**Package**: `packageVersion("TCGATranscriptionalMutSig")`

```{r setup, include=FALSE}
#set knitr chunk options
knitr::opts_chunk$set(warning = FALSE, message = FALSE, cache = TRUE)

#load packages to avoid startup messages later in the code
# suppressPackageStartupMessages({library(RnaSeqGeneEdgeRQL)})
library(ggplot2)
library(TCGAbiolinks)
library(SummarizedExperiment)
library(edgeR)
library(rtracklayer)
library(plyr)
library(org.Hs.eg.db)
library(GSEABase)
library(singscore)
library(reshape2)
library(gridExtra)
library(dcanr)

#ggplot theme
rl = 1.2
current_theme = theme_minimal() +
  theme(
    panel.border = element_rect(colour = 'black', fill = NA),
    panel.grid.minor = element_blank(),
    axis.title = element_text(size = rel(rl) * 1.1),
    axis.text = element_text(size = rel(rl)),
    plot.title = element_text(size = rel(rl)),
    strip.background = element_rect(fill = NA, colour = 'black'),
    strip.text = element_text(size = rel(rl)),
    legend.text = element_text(size = rel(rl)),
    legend.title = element_text(size = rel(rl), face = 'italic'),
    legend.position = 'bottom',
    legend.direction = 'horizontal'
  )

#automatically create a bib database for R packages
knitr::write_bib(c(
  .packages(), 'knitr', 'rmarkdown'
), 'packages.bib')
```

Introduction {#intro}
============

Cancers are a heterogeneous set of diseases with a number of clinical and pathological subtypes. In diseases such as breast cancer the primary clinical classifications relate to the expression of hormone receptors (estrogen receptor: ER; and progesterone receptor: PR) or the overexpression of Erb-B2 receptor tyrosine kinase (HER2), as these features can be directly targeted with therapeutic agents. For many other cancers, subtype classification has largely relied upon identifying sets of recurrent mutations across large patient cohorts, with whole genome or whole exome sequencing studies helping to resolve the clinically significant subtypes [@cancer13, @papaemmanuil16]. 

While genomic sequencing is important for classifying different tumour subsets based upon the presence of mutations or fusion genes, this provides little information on the state or phenotype of cells carrying these mutations. Fortunately the development of microarrays and more recently the rapid uptake of RNA-sequencing technologies have provided a platform to examine the transcriptional profile of biological samples [@cieslik18]. Transcriptomic analyses have traditionally focussed on 'differential expression' of genes between sets of samples, however with the rapid growth of publically available RNA data there has been increasing usage of 'relative approaches', which quantify the relative concordance of a sample or samples with a specific gene signature [@cieslik18]. A common example of transcriptomic or gene expression data informing clinical practice is the use of prediction analysis of microarray 50 (PAM50) signatures for distinguishing the intrinsic breast cancer subtypes [@cieslik18] + [cite].

Perhaps the most well-known 'relative approach' is single-sample gene set enrichment analysis (ssGSEA) [@barbie09], often used through the GenePattern web-tool (http://software.broadinstitute.org/cancer/software/genepattern/modules/docs/ssGSEAProjection/4). Another common approach is gene set variation analysis (GSVA) [@hanzelmann13] which is available as an R/Bioconductor package (https://bioconductor.org/packages/release/bioc/html/GSVA.html) that also includes functionality for ssGSEA, an alternative approach known as PLAGE [cite], and z-score approach. Both ssGSEA and GSVA use a Kolmogorov-Smirnov like random-walk statistic to convert normalised gene ranks to the resulting score, however this normalisation procedure means that the scores are not truly 'single-sample', and variations in the overall sample composition for a study (e.g. variations in the presence or relative abundance of different cancer subtypes) can lead to unexpected changes in sample scores. Furthermore, the resultant scores from these methods can vary in their range and absolute value, making them difficult to interpret without further processing. To overcome this, we have developed a single-sample gene set scoring method singscore [@foroutan18] (<http://bioconductor.org/packages/singscore/>) which simply uses the ranks of genes within a given set, normalised relative to the maximum and minimum theoretical scores for a gene set of a given size.

Through large scale efforts such as The Cancer Genome Atlas [**cite**] transcriptomic data are available for thousands of clinical samples, often together with corresponding genomic or epigenomic (often DNA methylation) data. These transcriptomic data can help to characterise the functional effects of corresponding mutations, and provide a window to study the heterogeneity which arises within different subtypes of cancer due to epigenetic and transcriptional regulatory programs which can also influence cell behaviour. Here, we demonstrate that the single-sample gene set scoring method singscore [@foroutan18] can be used to classify TCGA AML samples using transriptional 'gene signatures' for NPM1c mutation, KMT2A (MLL) gene fusions, and PML-RARA gene fusions that were derived from independent studies. Without any need for parameter fitting or estimation, we show that gene set scoring using the singscore this method can identify samples carrying these mutations with very high recall. The case studies we present demonstrate the application of gene set scoring to examine not only the differences, but also the relative similarities between established subtypes of AML that impact clinical outcome.

Description of the biological problem {#biol-problem}
=====================================

As with most cancers, acute myeloid leukemia (AML) is a heterogeneous cancer with a number of classified subtypes. Analysis of TCGA AML genomic data identified a number of AML subtypes based upon the presence of absence of specific 'driver mutations' which recapitulated a number of previously identified subsets [@cancer13]. A more recent study which focussed primarily on genomic data has further refined the clinically-significant AML subtypes [@papaemmanuil16], highlighting a number of co-occurring as well as mutually-exclusive mutations.

Of note for this work, one of the most common mutations in clinical AML samples is a frameshift mutation within exon 12 of the nucleophosmin (NPM1) gene [**cite**]. This mutation leads to abberant localisation of NPM1, leading to accumulation within the cytoplasm rather than the nucleolus, and accordingly this mutation is often referred to as the NPM1c mutation [**cite**]. As noted by @verhaak05, the NPM1c mutation is associated with dysregulated activity of the homeobox domain (Hox) family of transcription factors which are essential for developmental patterning [**cite**]. The effects of this mutation in disease progression have been further demonstrated in recent work which showed that loss of NPM1c leads to differentiation of AML cells [@brunetti18]. 

Further recurrent genetic lesions in AML relevant for this work include lysine methyl transferase 2A (KMT2A; previously known as MLL) fusion genes, partial tandem duplications within KMT2A (KMT2A-PTD), and fusion genes between promyelocytic leukemia and retinoic acid receptor alpha (PML-RARA). Given the role of NPM1c in dysregulating the Hox gene family, it is interesting to note that AML samples with MLL fusion genes also show dysregulated expression of Hox family genes [@hess04, @ross04]; however, samples with MLL-PTD appear to show a relatively distinct phenotype from MLL-fusion samples [@ross04].

In this workflow we demonstrate the ability of the singscore method for single sample gene set scoring [@foroutan18] to classify tumour 'driver mutations' from transcriptomic data. We use a previously identified gene signatures for the NPM1c mutation [@verhaak05], as well as signatures for PML-RARA gene fusions and MLL-fusions that were derived using pediatric AML samples but shown to work well for classifying adult AML samples with similar lesions [@ross04]. Using these signatures which are included within the molecular signatures database (MSigDB) [@liberzon15], we demonstrate that a bi-directional scoring approach can classify TCGA AML samples with corresponding mutations with a good precision and recall. A particularly useful feature of gene set scoring is the ability to project samples onto 2D or higher-order landscapes defined by corresponding phenotypic signatures. Accordingly, by comparing scores for both the NPM1c and KMT2A-/MLL-fusion signatures, we show that this classification likely arises through the shared downstream biological effects of Hox family dysregulation. We also compare the NPM1c mutation signature to the PML-RARA signature and show a clear separation of these subtypes reflecting their divergent phenotypes and the mutually-exclusive nature of these mutations.

Downloading and preparing the data {#download-and-prepare}
==================================

Data from the cancer genome atlas (TCGA) project is made available through the Genomic Data Commons (GDC). Open access data from the project can be accessed in multiple pre-processed formats. Transcriptomic data can be downloaded either at the count level or as FPKM trasformed, before or after upper quantile normalisation. Other pre-processed version can be found from sources such as the [www.cbioportal.org](http://www.cbioportal.org/) and [firebrowse.org](http://firebrowse.org). The GDC data used STAR to perform a two-pass alignment followed by quantification using HTSeq. Data from the GDC can be downloaded using the [GDC data transfer tool](https://gdc.cancer.gov/access-data/gdc-data-transfer-tool) which allows users to select the specific files of interest using the GDC portal. These files then have to be read, merged, annotated and processed into a data structure that simplifies downstream analysis. Alternatively, all the above mentioned steps, including the download, can be performed using the R package `TCGAbiolinks`. The package supports data download using the GDC API and the GDC client. We will use the TCGAbiolinks package to download, annotate and process the data into a SummarizedExperiment R object.

The following steps need to be performed to prepare the data:

1. Create a query to select the files to download
2. Execute the query and download the data
3. Read the data into R
4. Filter out genes with low expression
5. Normalise the data for compositional bias and transform to account for gene-length biases

Querying the GDC database {#gdc-query}
-------------------------

The first step in any analysis should be to determine and report the version of the data and the service used to download the data. The `getGDCInfo()` function returns the release date of all data on the GDC along with a version.

```{r gdc_query}
library(TCGAbiolinks)

#get GDC version information
gdc_info = getGDCInfo()
gdc_info
```

A query then needs to be run on the GDC to identify the specific files to download. This step is similar to generating a *MANIFEST* file using the GDC portal. The first parameter of the query specifies the project whose data needs to be downloaded. Available projects can be accessed using the `getGDCprojects()` or from <https://portal.gdc.cancer.gov/projects>. The TCGA acute myeloid leukemia data is part of the TCGA-LAML project. Following this, the data category, data type and workflow type need to be specified. The query formed below selects files containing the count level transcriptomic measurements. Values for different parameters of the query can be identified from "searching arguments" section of the "query" package vignette which can be accessed using `vignette("query", package = "TCGAbiolinks")`. The results of this query will be a dataframe containing filenames and additional annotations related to the files.

Read count level data are selected instead of the processed FPKM data as one of the downstream pre-processing analysis results in filtering out of genes. A general recommendation is to compute FPKM values after filtering genes out so as to ensure counts are normalised by the correct library sizes.

```{r gdc_results}
#form a query for the RNAseq data
query_rna = GDCquery(
  #getGDCprojects()
  project = 'TCGA-LAML',
  #TCGAbiolinks:::getProjectSummary('TCGA-LAML')
  data.category = 'Transcriptome Profiling',
  data.type = 'Gene Expression Quantification',
  workflow.type = 'HTSeq - Counts'
)

#extract results of the query
rnaseq_res = getResults(query_rna)
dim(rnaseq_res)
colnames(rnaseq_res)
```

Downloading the TCGA AML RNA-seq read counts {#download-data}
--------------------------------------------

The `GDCdownload` function then executes the query on the GDC database and begins downloading the data using the GDC API. The download method should be changed to "client", if the size of the data is expected to be large. This would mostly be the case if data downloaded are reads or methylation data. It is good practice to specify the directory where the data will be stored therefore we store all the data to the "GDCdata" directory. The function downloads the data and organises it into the folder based on the parameters specified in the query. This allows multiple different levels and types of data to be stored in the same directory structure. Files with counts are stored at *./GDCdata/TCGA-LAML/harmonized/Transcriptome_Profiling/Gene_Expression_Quantification/*.

```{r gdc_download, results='hide'}
datapath = './GDCdata'
GDCdownload(query_rna, directory = datapath) #(size: 39MB)
```

Reading count-level data into R {#read-data}
-------------------------------

The `GDCprepare` function reads and processes the downloaded data into a `RangedSummarizedExperiment` object which allow patient annotations, gene annotations and count data to be stored in one object. Patient annotations are downloaded upon calling this function and subsequently mapped and attached to the resulting object. A RangedSummarizedExperiment object is similar to an ExpressionSet object but provides added functionality such as indexing with genomic coordinates and storing multiple data matrices with the same structure. Feature annotations used to annotate the data are stored in an RDA/RDATA file.

```{r gdc_prepare, results='hide'}
aml_se = GDCprepare(query_rna, directory = datapath)
```

The object contains data for 56,925 features and 151 samples. The original data files contain 60,483 features, some of which could not be mapped to GRCh38.p12 (3,767). Feature and sample annotations can be accessed using `rowData(se)` and `colData(se)` respectively and the counts data can be accessed using `assay(se)`. The TCGA data usually contains some formalin-fixed paraffin-embedded (FFPE) samples which should be discarded from the analysis as the protocol introduces biological artefacts. This procedure is only performed on solid tumours and not leukemias, therefore, no filtering is required for this data set.

```{r show_se}
aml_se
```

Filter out genes with low counts {#filter-data}
--------------------------------

The `edgeR` package contain methods that assist in data normalisation and transformation which are required for filtering and subsequent steps. The methods require a DGEList object therefore we begin by creating a DGEList for the AML data from the SummarizedExperiment. Creation of a DGEList object is initially unsuccessful due to duplicated row names in the data matrix (176 features). The raw count files for individual samples do not have any duplicated features indicating this is introduced by the `GDCprepare` function. This is further supported by the fact that the counts for a single feature are the same for duplicated entries. An example of such a feature is shown below and we have verified duplicated entries of all other features to be the same.

```{r dup_entries}
library(SummarizedExperiment)

#example check on one feature ID
dup_feature = 'ENSG00000277610'
dup_data = assay(aml_se[rownames(aml_se) %in% dup_feature, ])
identical(dup_data[1, ], dup_data[2, ])
```

As such, it is safe to discard duplicated entries.

```{r remove_dups}
library(edgeR)

aml_se = aml_se[!duplicated(rownames(aml_se)), ]
aml_dge = DGEList(counts = assay(aml_se), genes = rowData(aml_se))
```

Genes with low counts across most samples are discarded from the analysis. This is a standard step in differential expression analysis as inclusion of such genes in the analysis could skew estimates of dispersion. It is also motivated in rank-based analysis, such as with singscore, to avoid rank duplication. Rank duplication reduces the discriminant power of scores as the number of unique ranks is reduced. A commonly used filter is to select only those genes that have CPMs above a certain threshold across a proportion of samples. Filtering is performed on the CPMs rather than raw counts as the former is invariant to library sizes, therefore, unbiased. For instance, a CPM of 1 would equate to read counts between 19 and 50 for samples in the AML data where library sizes vary between 18.6 and 49.7 million reads. Here, we retain genes that have a CPM > 1 across more than 50% of the samples. Other methods to filter out genes with low counts exists and may be preferable in specific applications. @chen16 and @law16 filter genes based on the experimental design whereby the proportion of samples with enough read counts are evaluated per experimental group. As the AML data have many samples and lack rare groups, filtering is performed across all samples rather than within groups. Group specific filtering would be recommended if the study of interest would be focused on rare groups. The distribution of logCPMs improves significantly after filtering out genes with low counts as seen in Figure \@ref(fig:plot-hist-filtering).

```{r plot-hist-filtering, fig.wide=TRUE, fig.cap="Histogram of logCPM values for the AML data before and after filtering. Filtering results in fewer zeros in the data. Most of the genes with logCPM less than 0 (red line) across the majority of samples get discarded."}
prop_expressed = rowMeans(cpm(aml_dge) > 1)
keep = prop_expressed > 0.5

op = par(no.readonly = TRUE)
par(mfrow = c(1, 2))
hist(cpm(aml_dge, log = TRUE), main = 'Unfiltered', xlab = 'logCPM')
abline(v = log(1), lty = 2, col = 2)
hist(cpm(aml_dge[keep, ], log = TRUE), main = 'Filtered', xlab = 'logCPM')
abline(v = log(1), lty = 2, col = 2)
par(op)
```

```{r remove_low_counts}
#subset the data
aml_dge = aml_dge[keep, , keep.lib.sizes = FALSE]
aml_se = aml_se[keep, ]
```

Transformation to FPKM values and normalisation {#calc-fpkm}
-----------------------------------------------

Singscore requires gene expression measurements to be comparable between genes, therefore, correction for gene length biases needs to be performed. Transformations such as transcripts per million (TPM) and reads/fragments per kilobase per million (RPKM/FPKM), that normalise by gene length, may be used. Both, TPM and RPKM/FPKM values should produce similar results when applying singscore provided that the library size is large enough, which it is here. RPKM values are generally computed after correcting for compositional biases. The `calcNormFactors` function in edgeR provides three methods to do so, TMM normalisation being the default. @chen16 and @law16 discuss the implications of normalisation prior to down-stream processing. Normlisation is generally performed for cross-sample analysis where samples need to be comparable. Singscores are invariant to data normalisation as the analysis is contained within the sample of interest. The idea extends to any transformation that preserves the relative ranks of genes within a sample such as a log transformation. Here, we normalise the samples using TMM normalisation solely for visualisation purposes.

Data transformations to TPM or RPKM/FPKM require the gene lengths for all genes to be calculated. Gene lengths need to be computed based on the alignment and quantification parameters. The TCGA transcriptomic data has been aligned using STAR and quantified using HTSeq (details of the pipeline available at <https://docs.gdc.cancer.gov/Data/Bioinformatics_Pipelines/Expression_mRNA_Pipeline/>). HTSeq quantifies reads mapping to the exons of each gene, therefore, effective gene lengths can be calculated as the sum of all exons spanning the gene. The GENCODE v22 annotation file was used for quantification therefore the same file needs to be used to compute gene lengths.

```{r download_gencode, results='hide'}
#download v22 of the GENCODE annotation
gencode_file = 'gencode.v22.annotation.gtf.gz'
gencode_link = paste(
  'ftp://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_human/release_22',
  gencode_file,
  sep = '/'
  )
download.file(gencode_link, gencode_file, method = 'libcurl') #(size: 39MB)
```

The `rtracklayer` R package provides functions to help parse GTF files.

```{r compute_gene_lengths}
library(rtracklayer)
library(plyr)

gtf = import.gff(gencode_file, format = 'gtf', genome = 'GRCm38.71', feature.type = 'exon')
#split records by gene to group exons of the same gene
grl = reduce(split(gtf, elementMetadata(gtf)$gene_id))
gene_lengths = ldply(grl, function(x) {
  #sum up the length of individual exons
	return(c('gene_length' = sum(width(x))))
}, .id = 'ensembl_gene_id')
```

Genes are also annotated with their biotype for further analysis. The annotation file uses Ensembl IDs with versions as keys to records, which then need to be converted to Ensembl IDs. This is simply achieved by concatenating the trailing version number.

```{r add_biotype}
#extract information on gene biotype
genetype = unique(elementMetadata(gtf)[, c('gene_id', 'gene_type')])
colnames(genetype)[1] = 'ensembl_gene_id'
gene_lengths = merge(genetype, gene_lengths)

#remove ENSEMBL ID version numbers
gene_lengths$ensembl_gene_id = gsub('\\.[0-9]*', '', gene_lengths$ensembl_gene_id)
saveRDS(gene_lengths, file = 'gene_lengths_HTSeq_gencodev22.rds')
gene_lengths
```

The SummarizedExperiment object allows feature annotations to be stored, therefore, information on gene length and biotypes should be added to the existing annotations. Similarly, annotations need to be added to the DGEList object with the column name consisiting the word "length".

```{r add_length_annotation}
#allocate rownames for ease of indexing
rownames(gene_lengths) = gene_lengths$ensembl_gene_id
rowData(aml_se)$gene_length = gene_lengths[rownames(aml_se), 'gene_length']
rowData(aml_se)$gene_biotype = gene_lengths[rownames(aml_se), 'gene_type']

#annotate gene lengths for the DGE object
aml_dge$genes$length = gene_lengths[rownames(aml_dge), 'gene_length']
```

RPKM/FPKM values can now be calculated with the computed gene lengths after computing the normalisation factors. The SummarizedExperiment object can store multiple levels of the data simultaneously, provided that the number of features and samples remains the same across measurements. As such, FPKM values are appended to the existing object. All three normalisation methods will be performed and their resulting FPKM values stored in the SummarizedExperiment object. This will allow comparison of the signature scores computed from all three processing methods simultaneously.

```{r compute_fpkm}
aml_dge_tmm = calcNormFactors(aml_dge, method = 'TMM')

#compute FPKM values and append to assays
assay(aml_se, 'logFPKM_TMM') = rpkm(aml_dge_tmm, log = TRUE)
aml_se
```

Annotate samples with mutation data {#annotate-mutations}
-----------------------------------

Original file at <https://tcga-data.nci.nih.gov/docs/publications/aml_2012/SupplementalTable01.xlsx>

```{r preproc_mutations, eval=FALSE, include=FALSE}
#preprocessing - read tsv (Joe's version) and convert save as RDS
mut_info = read.csv('PatientMutations.tsv', sep = '\t', colClasses = c('character', rep('logical', 8)))
rownames(mut_info) = mut_info$Barcode
mut_info = mut_info[, -1]
patients = mut_info[substring(colnames(aml_se), 1, 12), ]
rownames(patients) = colnames(aml_se)
saveRDS(patients, file = 'AMLPatientMutationsTCGA.rds')
```

```{r annotate_mutations}
patient_mutations = readRDS('AMLPatientMutationsTCGA.rds')
aml_mutations = colnames(patient_mutations)
colData(aml_se) = cbind(colData(aml_se), patient_mutations)
colData(aml_se)[, aml_mutations]
```

Map Ensembl IDs to Entrez IDs {#map-gene-ids}
-----------------------------

RefSeq annotations (Entrez IDs) may be more suited to RNA-seq analysis which requires a stable reference annotation to align against [@wu13]. In contrast, Ensembl annotations (Ensembl IDs) have higher coverage of the genome which may be useful in applications such as variant calling and similar exploratory analysis [@zhao15]. As such, we choose to map Ensembl IDs to Entrez IDs and discard any unmapped features.

Mapping can be performed using the Ensembl Biomart service which can be queried using the biomaRt bioconductor package. This would provide the most up to date annotations. Alternatively, mapping could be performed with the bi-annually updated `org.Hs.eg.db` annotation R package which provides a stable set of annotations, thereby enhancing reproducibility. Mapping is performed with the `mapIds` function in the `AnnotationDbi` R package.

```{r map_ensembl_entrez}
library(org.Hs.eg.db)

rowData(aml_se)$entrezgene = mapIds(
  org.Hs.eg.db,
  keys = rownames(aml_se),
  keytype = 'ENSEMBL',
  column = 'ENTREZID',
  multiVals = 'asNA'
  )
gene_annot = rowData(aml_se)
```

Multimapped Ensembl IDs are replaced by `NAs`, then discarded to enforce unique mapping. Similarly, Entrez IDs that map to multiple Ensembl IDs are identified from the mapping, and discarded. Only features with unique Ensembl ID and Entrez ID mappings remain.

```{r discard_multimapped_genes}
#select genes with mapped Entrez IDs
keep = !is.na(gene_annot$entrezgene)

#select genes with unique Entrez IDs
dup_entrez = gene_annot$entrezgene[duplicated(gene_annot$entrezgene)]
keep = keep & !gene_annot$entrezgene %in% dup_entrez

#Biotype of genes discarded due to non-unique mapping
head(sort(table(gene_annot[!keep, 'gene_biotype']), decreasing = TRUE), n = 10)

#subset the data
aml_se = aml_se[keep, ]
```

Transcriptional signatures to predict mutation status {#transcriptional-mut-sig}
=====================================================

The signature by @verhaak05 is now used to predict the mutation status of the NPM1c mutation. This is done by quantifying the concordance of genes in the signature with their expression in each sample. As such, high expression of up-regulated genes and low expression of down-regulated genes would result in higher scores. This single value can then be used to predict the mutation status of individual samples.

The signatures of interest are first downloaded from the MSigDB and read into `GeneSet` objects from the `GSEABase` R package. We then use the `singscore` R/Bioconductor package to quantify each sample for the Verhaak signature. Some of the visualisation and diagnostic tools within the `singscore` package are used to interpret the signatures and scores. Finally, we use a simple logistic regression model on the scores to predict the mutation status.

Download signature and load into R {#prepare-signature}
----------------------------------

The @verhaak05 signature is composed of an up-regulated and a down-regulated gene set. Many signatures are developed in such a manner to improve discrimination of samples. MSigDB stores such signatures using names with suffixes "_UP" and "_DN" representing the independent components of the signature. Here, we form the download links for the signature with the base name "VERHAAK_AML_WITH_NPM1_MUTATED".

```{r signature_names}
#create signature names
verhaak_names = paste('VERHAAK_AML_WITH_NPM1_MUTATED', c('UP', 'DN'), sep = '_')
verhaak_names
```

The signatures are then downloaded using the links, resulting in an XML file for each component of the signature. The `mapply` function is used to run the download function on all pairs of link-output arguments.

```{r download_signatures, results='hide'}
#generate URLs
verhaak_links = paste0(
  'http://software.broadinstitute.org/gsea/msigdb/download_geneset.jsp?geneSetName=',
  verhaak_names,
  '&fileType=xml'
  )

#download files
verhaak_files = paste0(verhaak_names, '.xml')
mapply(download.file, verhaak_links, verhaak_files, method = 'libcurl')
```

Functions in the `GSEABase` package help in reading, parsing and processing the signatures. Signatures from an MSigDB XML file can be read using the `getBroadSets` function which results in a `GeneSet` object. Gene symbols, Entrez IDs and affymetrix chip IDs from the original experiment (HG-U133A in this case) are stored in the XML file. Entrez IDs are read from the file as these can be mapped directly to our data. Conversions to other identifiers can be achieved using `mapIdentifiers` package from `GSEABase` and an annotation package that contains the mappings. The advantage of using this function instead of the `mapIds` function from the `AnnotationDb` package is that the former retains the `GeneSet` object after conversion of IDs.

```{r read_signatures}
library(GSEABase)

verhaak_sigs = getBroadSets(verhaak_files, membersId = 'MEMBERS_EZID')
verhaak_sigs
```

To ease indexing of the data when scoring using the signatures, rownames of the `SummarisedExperiment` object are changed to Entrez IDs which are already part of the row annotations.

```{r rows_to_entrez}
rownames(aml_se) = rowData(aml_se)$entrezgene
```

Score TCGA AML samples using the Verhaak signature {#score-samples}
--------------------------------------------------

Singscore is a rank based metric of gene set enrichment in single samples. Scores for multiple signatures make use of the same ranked expression per sample. As such, it makes sense to compute the ranks only once and re-use them for scoring different signatures. The implementation separates these two phases of the analysis to reduce the computational cost of scoring. The `rankGenes` function will compute ranks from expression data in the form of either a numeric matrix, numeric data frame, ExpressionSet object, DGEList object or a SummarizedExperiment object. Users also have to specify what method should be used to break ties. The default is 'min' and we recommend this be used for RNA-seq data which may have many genes with zero counts. This will reduce the effect of zeros in the scores, however, appropriate pre-filtering of genes with low counts will still be required (see Section \@ref(filter-data)).

```{r compute_ranks_aml}
library(singscore)

#apply the rankGenes method to each version of the dataset, excluding counts
aml_ranked = rankGenes(assay(aml_se, 'logFPKM_TMM'))
```

Singscores can be computed using three modes, depending on the properties of the gene signature. The first mode of operation is applied when two gene sets (up- and down- regulated gene sets) form the transcriptomic signature. Many signatures in the MSigDB, including the @verhaak05 signature come in such pairs. This mode can be invoked by passing the up- and down-regulated gene sets to the arguments `upSet` and `downSet` respectively. In most cases, only one set of genes forms the signature. If all genes in the gene set are up-regulated or all down-regulated, the second mode of operation applies and is invoked by passing the gene set to the `upSet` argument. For sets of down-regulated genes, the score would simply be inverted (-score if scores are centered, 1 - score otherwise). Finally, if the user is unsure of the composition of genes in the gene-set, such that, the gene set may contain both up- and down- regulated genes, the final mode of singscore applies. The gene set is passed to the `upSet` argument similar to the previous mode with the additional argument `knownDirection` set to `FALSE`.

By default, singscores are centered such that the range of scores is $[-1, 1]$ and $[-0.5, 0.5]$ for the first two modes respectively. Scores from the last mode can not be centered and have the range $[0, 1]$. In this mode, high scores are obtained when ranks of genes are distant from the median and low scores obtained when ranks converge to the median rank. If scores are centered in this scenario, it would lead to the conclusion that a negative score shows inverted enrichment, which is not the case. Negative scores in the former two modes indicate inverted enrichment of signatures, that is, up-regulated genes are in fact down-regulated and vice-versa. Score centering only serves the purpose of easing interpretation for users, a simple linear transformation is applied to achieve it.

Scores for the NPM1c mutation signature are computed using the default settings, with the first mode of operation being used due to the presence of an up- and down- regulated gene set. The function returns a data frame reporting the score and dispersion of ranks for the up-regulated gene set, down-regulated gene set and the combination of both. Dispersion of the combined gene set in this mode is simply the mean of the independent dispersion estimates. The list of gene names/IDs present in the signature but missing in the data, if any, will be reported as a warning.

```{r compute_scores_verhaak, warning=TRUE}
#apply the scoring function
verhaak_scores = simpleScore(aml_ranked,
                             upSet = verhaak_sigs[[1]],
                             downSet = verhaak_sigs[[2]])
```

It should be noted that singscores are in fact two-dimensional scores. The quantity of interest in gene set enrichment is the distribution of the expression or ranks of genes in the signature. In an ideal scenario, all up-regulated genes would have high expression therefore higher values of ranks. As such, ranks would be distributed on the higher end of the entire rank spectrum. Singscore aims to quantify this distribution of ranks, therefore, computes and reports the average and dispersion of ranks of genes in the signature relative to all other genes. The first quantity is similar to scores computed from all other single sample scoring methods. We determined a two-dimensional score to be a more appropriate and accurate representation of the distribution of ranks of signature genes. The default and recommended measure of dispersion is the median absolute deviation (MAD) due to its non-parametric property. Other appropriate measure of dispersion could be the inter-quartile range (IQR) and can be used by passing the `IQR` function as an argument to the `dispersionFun` argument.

```{r}
head(verhaak_scores)
```

Diagnostics of the Verhaak signature {#diagnostics-verhaak}
------------------------------------

The `singscore` package provides a set of visualisation tools that enable diagnostics of the gene signature. For instance, these tools may be used to determine the importance of each signature of a dual signature (up- and down-regulated genes) to the total score, determine the importance of each gene of a signature in discriminating between the classes of interest and to look at the relationship between the final score and the dispersion of ranks. Annotations of interest can be overlayed on each plot. We begin by investigating the relationship between the score and dispersion of ranks of expression for the up-regulated gene signature, down-regulated gene signature and the full signature.

```{r plot-dispersion, fig.wide=TRUE, fig.height=4, fig.cap="Total scores, scores for up-regulated genes, and scores for down-regulated genes for all samples. Scores are plot agains the median absolute deviation of the ranks of genes in each signature."}
#create annotation
mutated_gene = rep('Other', ncol(aml_se))
mutated_gene[aml_se$NPM1.Mut] = 'NPM1 Mut'
mutated_gene[aml_se$KMT2A.Fusion | aml_se$KMT2A.PTD] = 'MLL Fusion/PTD'
p1 = plotDispersion(verhaak_scores, annot = mutated_gene)
p1
```

Figure \@ref(fig:plot-dispersion) shows that the set of down-regulated genes has more discriminant power in separating NPM1c mutated samples from those those without. Moreover, the signature is able to discriminate MLL(KMT2A) fusions and PTDs from the other samples. NPM1c mutations produce higher scores for the down-regulated gene set while MLL fusions and PTDs produce moderate scores. Similar trends are observed with the set of up-regulated genes, however, despite the range of scores increasing, the discriminant power drops moderately. In fact, the signature of up-regulated genes is able to discriminate samples without the genomic changes of interest ('Other') better by producing negative scores for most of these samples. Negative scores for the up-regulated signature indicate that these genes are expressed below median expression, therefore, likely down-regulated. Another observation from these plots is based on the trend of the dispersion (MAD). The dispersion is generally expected to be higher for scores close to zero. Zero scores are achieved in three possible scenarios: when genes are expressed at median expression level; when genes are evenly distributed at both ends of the expression spectrum; or, the more likely scenario whereby the rank of expression of all genes are uniformly distributed. The last two scenarios would result in a high dispersion. To explain these ideas, we select 3 samples and plot the ranks of genes in both signatures. The sample with the highest total score, lowest total score and highest dispersion are chosen.

```{r plot-rank-density, fig.wide=TRUE, fig.height=4, fig.cap="Rank distribution of genes in the Verhaak signature for 3 samples. The barcode plot for ranks of genes in each signature along with the density of the ranks is shown in each plot. Up-regulated genes are represented in green and down-regulated in purple"}
library(gridExtra)

#select samples with the properties required
select_samples = c(
  'Max Total Score' = which.max(verhaak_scores$TotalScore),
  'Min Total Score' = which.min(verhaak_scores$TotalScore),
  'Max Dispersion' = which.max(verhaak_scores$TotalDispersion)
  )

#plotRankDensity applied to each sample
rank_plots = lapply(names(select_samples), function(x) {
  #get the sample index
  aml_sample = select_samples[x]
  #drop = FALSE is required to ensure the data.frame is intact
  p1 = plotRankDensity(rankData = aml_ranked[, aml_sample, drop = FALSE],
                       upSet = verhaak_sigs[[1]],
                       downSet = verhaak_sigs[[2]],
                       textSize = 1)
  
  #overwrite title of the plot with the description of the sample
  p1 = p1 + ggtitle(paste(x,  mutated_gene[aml_sample], sep = '\n')) +
    theme(legend.title = element_blank())
  return(p1)
})

#create a multipanel plot
grid.arrange(grobs = rank_plots, nrow = 1)
```

Figure \@ref(fig:plot-rank-density) shows that both the up- and down-regulated genesets contribute to the score of the top scoring sample as these genes are at the extremes ends of the rank spectrum. Similarly, the lowest scoring sample has the ranks of genes in each set inverted. As observed in the previous plot, the up-regulated genes improve the discrimination between NPM1 mutated samples and other samples and may be a stronger indicator of wild-type NPM1 samples than the down-regulated genes. Finally, the sample with the maximum dispersion exhibits uniformly distributed down-regulated gene ranks and a bimodal distribution of the up-regulated gene ranks with the modes at the extremes of the spectrum.

Combined, these plots show that both the up- and down-regulated genes play an important role in discriminating between NPM1 mutated (and MLL fusion/PTD samples), and wild-type samples. These diagnostic plots help in determining the importance of genes in signatures with respect to the samples of interest and should be used prior to application of signatures. Many signatures have been developed in specific contexts due to inherent biases in datasets and yet been described in a generalised setting **cite**. These diagnostic plots may help in validating their application in specific contexts and possibly assist in characterising the contexts of all existing signatures.

Predicting mutations using the Verhaak signature {#predict-verhaak}
------------------------------------------------

Mutation status can be predicted from singscores using a logistic regression model with a "logit" link function. The benefits of this model over one where each gene in the signature is used as a term in the model is the simplicity of the model. The @verhaak05 signature consists of 429 genes which would result in a regression model with 429 predictors. As the number of samples is smaller than the predictors, some feature selection method would be required which may result in the loss of information. Moreover, more signatures would require more such models thereby limiting automated application on a larger scale (for example across all signatures on the MSigDB). Additionally, models trained using singscore would inherit its non-parametric properties to some extent. For instance, such models would be invariant to all data transformations that retain within sample ranks of genes. The main limitation of such models would be the loss of accuracy due to summarisation of the data (information on 429 genes is summarised into a two-dimensional score).

In any case, our aim here is not to discuss the various models that can be used to predict mutation status, but to exhibit the discriminant power of singscore and transcriptomic signatures. As such, the data used to train the model is used to evaluate the basic performance properties. We begin by combining the scores with mutation annotations.

```{r create_plotdf_boxplot}
#create a dataframe with the data required: scores and mutations
scoredf = as.data.frame(colData(aml_se)[, aml_mutations])
scoredf$Score = verhaak_scores$TotalScore
scoredf$Dispersion = verhaak_scores$TotalDispersion
```

Before training a model, we can visualise how well scores resulting from the @verhaak05 signature separate the mutants from wild-types for some genes of interest. Figure \@(fig:plot-boxplot-mutscores) shows that NPM1c signature scores can discriminate between NPM1c wild-type and mutants. Similar observations are made for genomic changes such as the MLL (KMT2A) fusions, FLT3 mutations and the PML-RARA fusion.

```{r plot-boxplot-mutscores, fig.wide=TRUE, fig.height=5, fig.cap="Boxplot of scores from the NPM1c signature split by different types of mutations."}
#restructure the data for ploting
plotdf = melt(
  scoredf,
  id.var = c('Score', 'Dispersion'),
  variable.name = 'Mutation',
  value.name = 'Status'
  )
#convert TRUE-FALSE values to Mut-WT
plotdf$Status = factor(plotdf$Status, labels = c('WT', 'Mut'))
p1 = ggplot(plotdf, aes(Mutation, Score, fill = Status)) +
  geom_boxplot(position = 'dodge', alpha = 0.6) +
  scale_fill_brewer(palette = 'Set2') +
  current_theme +
  theme(axis.text.x = element_text(angle = 45, vjust = 0.5))
p1
```

To quantify the above observations, we fit logistic regression models with each gene as the response variable and the score as the predictor. Coefficient estimantes, standard errors, z-statistic, and $p$-values of each model are listed below.

```{r predict_mutation_glm}
#fit GLMs to each mutation
glms = lapply(aml_mutations, function(x) {
  #generate a formula for the fit
  form = as.formula(paste0(x, ' ~ Score'))
  glm1 = glm(form, data = scoredf, family = binomial(link = 'logit'))
  return(glm1)
})
names(glms) = aml_mutations

#extract coefficients
coefs = lapply(glms, function(x) coef(summary(x)))
ldply(coefs, function(x) x[2, ], .id = 'Mutation')
```

NPM1 mutations are significantly associated with the score. DNMT3A mutations, FLT3 mutations, PML-RARA, and MLL Fusions are also associated with the score, though with a lower significance.

> PML-RARA coefficient is -ve so PML-RARA have low NPM1c score, any significance?

Evaluate prediction model performance {#prediction-performance}
-------------------------------------

The above statistics give insight on the models trained but not on their performance. Precision and recall provide insight on a models predictive performance. The `dcanr` package provides functions to compute these metrics along with other measures of performance.

```{r eval_prediction_performance}
library(dcanr)

#assess sensitivity and specificity
prec_rec = ldply(glms, function(glm1) {
  #predict mutations for the data used in training and convert to binary format
  prediction = as.numeric(predict(glm1) > 0)
  observed = glm1$y
  prec = performanceMeasure(prediction, observed, 'precision')
  recall = performanceMeasure(prediction, observed, 'recall')
  f1 = performanceMeasure(prediction, observed)
  return(c('Precision' = prec, 'Recall' = recall, 'F1' = f1))
}, .id = 'Mutation')
prec_rec
```

Precision for predictions of all genes other than NPM1 and DNMT3A is undefined because all samples are predicted to be wild-types. Consequently, their recall is zero. Precision, recall and the F1 score of the NPM1 mutation model are high as expected. As mentioned in Section \@ref(score-samples), singscores are two-dimensional scores , therefore, performance may be further improved by including the dispersion of ranks. This is observed in Figure \@ref(fig:plot-dispersion).

As observed from the model below, using the two-dimensional singscore significantly improves the predictive performance.

```{r predict_with_mads}
#include dispersion in the model
glm_npm1 = glm('NPM1.Mut ~ Score + Dispersion',
               data = scoredf,
               family = binomial(link = 'logit'))

#evaluate performance of the new model
prediction = as.numeric(predict(glm_npm1) > 0)
observed = glm_npm1$y
c(
  'Precision' = performanceMeasure(prediction, observed, 'precision'),
  'Recall' = performanceMeasure(prediction, observed, 'recall'),
  'F1' = performanceMeasure(prediction, observed)
  )
```

Signature landscapes with multiple signatures {#signature-landscape}
=============================================

Often, we are interested in the relationship between two dependent or independent phenotypes, for instance, the epithelial and mesenchymal phenotypes. The role of most signatures is to estimate an unobservable molecular phenotype so they may be considered as proxies of phenotypes. As such, we could investigate the relationship between two phenotypes using the their signatures. @cursons18 introduced the idea of molecular signature landscapes to investigate the relationships between any two signatures. They applied the signature to the epithelial and mesenchymal phenotypes and demonstrated its usage in identifying the shift to an epithelial phenotype of miR-200c induced mesenchymal cell lines. @foroutan18 used signature landscapes to stratifying breast cancer subtypes along the epithelial-mesenchymal axis and included it as part of the `singscore` package. Here, we show how such landscapes can be used beyond the current application of the epithelial-mesenchymal axis. We demonstrate how transcriptomic signatures of different mutations can be used to stratify AML samples.

Ross MLL fusion signature vs. Verhaak signature landscape {#sig-landscape-mll}
---------------------------------------------------------



```{r process_rossmll_sigs}
#create signature names
rossmll_names = 'ROSS_AML_WITH_MLL_FUSIONS'
#generate URLs
rossmll_links = paste0(
  'http://software.broadinstitute.org/gsea/msigdb/download_geneset.jsp?geneSetName=',
  rossmll_names,
  '&fileType=xml'
  )

#download files
rossmll_files = paste0(rossmll_names, '.xml')
mapply(download.file, rossmll_links, rossmll_files, method = 'libcurl')
rossmll_sigs = getBroadSets(rossmll_files, membersId = 'MEMBERS_EZID')
```

AML samples are then scored using the new signature. Ranks computed in Section \@ref(score-samples) can be reused to compute scores with the new signature.

```{r score_rossmll}
rossmll_scores = simpleScore(aml_ranked, rossmll_sigs[[1]])
```

```{r plot-signature-landscape, fig.height=7, fig.width=7, fig.cap="Signature landscape."}
p1 = plotScoreLandscape(
  verhaak_scores,
  rossmll_scores,
  scorenames = c('VERHAAK_AML_WITH_NPM1_MUTATED', 'ROSS_AML_WITH_MLL_FUSIONS'),
  textSize = 1.4
  )
#we modify the number of bins in the landscape to ensure they are not too sparse
p1
```

```{r new_annotations}
#new annotation - modify previously used annotations
mutated_gene[aml_se$KMT2A.Fusion] = 'MLL Fusion'
mutated_gene[aml_se$KMT2A.PTD] = 'MLL PTD'
mutated_gene[aml_se$PML.RARA] = 'PML-RARA'
```

```{r plot-project-mll, fig.height=7.5, fig.width=7, fig.cap="Signature landscape with projections."}
select_aml = !mutated_gene %in% 'Other'
#project above mutations onto the landscape
p2 = projectScoreLandscape(p1,
                           verhaak_scores,
                           rossmll_scores,
                           subSamples = select_aml,
                           annot = mutated_gene[select_aml])
p2
```

Ross PML-RARA fusion signature vs. Verhaak signature landscape {#sig-landscape-pmlrara}
--------------------------------------------------------------

```{r plot-project-pmlrara, fig.height=7.5, fig.width=7, echo=FALSE, fig.cap="Signature landscape with projections."}
newsig_name = 'ROSS_AML_WITH_PML_RARA_FUSION'
#generate URL
newsig_link = paste0(
  'http://software.broadinstitute.org/gsea/msigdb/download_geneset.jsp?geneSetName=',
  newsig_name,
  '&fileType=xml'
)

#download files
newsig_file = paste0(newsig_name, '.xml')
download.file(newsig_link, newsig_file, method = 'libcurl')
newsig_sig = getBroadSets(newsig_file, membersId = 'MEMBERS_EZID')

#score
newsig_scores = simpleScore(aml_ranked, newsig_sig[[1]])

#plot and project
p1 = plotScoreLandscape(
  verhaak_scores,
  newsig_scores,
  scorenames = c('VERHAAK_AML_WITH_NPM1_MUTATED', newsig_name),
  textSize = 1.4
)

#project NPM1 mutations onto the landscape
mutated_gene = rep('Other', ncol(aml_se))
mutated_gene[aml_se$NPM1.Mut] = 'NPM1 Mut'
mutated_gene[aml_se$KMT2A.Fusion] = 'MLL Fusion'
mutated_gene[aml_se$KMT2A.PTD] = 'MLL PTD'
mutated_gene[aml_se$PML.RARA] = 'PML-RARA'
select_aml = !mutated_gene %in% 'Other'

p2 = projectScoreLandscape(p1,
                           verhaak_scores[, 1:2],
                           newsig_scores,
                           subSamples = select_aml,
                           annot = as.factor(mutated_gene[select_aml]))
p2
```

Packages used {.unnumbered}
=============

This workflow depends on various packages from version `r BiocManager::version()` of the Bioconductor project, running on `r version$version.string` or higher. The complete list of the packages used for this workflow are shown below:

```{r session_info}
sessionInfo()
```

Additional analysis {.unnumbered}
===================

References {.unnumbered}
==========