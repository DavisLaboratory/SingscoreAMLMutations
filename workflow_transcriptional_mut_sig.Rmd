---
title: "Transcriptional signatures for mutations"
author:
  - name: Dharmesh D Bhuva
    affiliation:
      - Bioinformatics Division, Walter and Eliza Hall Institute of Medical Research, Parkville, VIC 3052, Australia
      - School of Mathematics and Statistics, University of Melbourne, Parkville, VIC 3010, Australia
    email: bhuva.d@wehi.edu.au
  - name: Momeneh Foroutan
    affiliation:
      - Department of Clinical Pathology, The University of Melbourne Centre for Cancer Research, Victorian Comprehensive Cancer Centre, Melbourne, Victoria 3000, Australia
    email: momeneh.foroutan@unimelb.edu.au
  - name: Ruqian Lyu
    affiliation:
      - Bioinformatics Division, Walter and Eliza Hall Institute of Medical Research, Parkville, VIC 3052, Australia??
    email: ??
  - name: Joseph Cursons
    affiliation:
      - Bioinformatics Division, Walter and Eliza Hall Institute of Medical Research, Parkville, VIC 3052, Australia
      - Department of Medical Biology, University of Melbourne, Parkville, VIC 3010, Australia
    email: cursons.j@wehi.edu.au
  - name: Melissa J Davis
    affiliation:
      - Bioinformatics Division, Walter and Eliza Hall Institute of Medical Research, Parkville, VIC 3052, Australia
      - Department of Medical Biology, University of Melbourne, Parkville, VIC 3010, Australia
    email: davis.m@wehi.edu.au
date: "`r format(Sys.time(), '%d %b %Y')`"
output:
  # BiocWorkflowTools::f1000_article
  BiocStyle::html_document:
    toc_float: true
    fig_caption: true
    number_sections: true
bibliography: [bibliography.bib, packages.bib]
vignette: |
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
keywords: Please list up to eight keywords to help readers interested in your article find it more easily.
abstract: >
  Transcriptional signatures for mutations
---

**R version**: `r R.version.string`

**Bioconductor version**: `r BiocManager::version()`

**Package**: `packageVersion("TCGATranscriptionalMutSig")`

```{r setup, include=FALSE}
#set knitr chunk options
knitr::opts_chunk$set(warning = FALSE, message = FALSE, cache = TRUE)

#load packages to avoid startup messages later in the code
# suppressPackageStartupMessages({library(RnaSeqGeneEdgeRQL)})
library(ggplot2)
library(TCGAbiolinks)
library(SummarizedExperiment)
library(edgeR)
library(rtracklayer)
library(plyr)
library(org.Hs.eg.db)
library(GSEABase)
library(singscore)
library(reshape2)
library(gridExtra)
library(caret)
library(PharmacoGx)

#ggplot theme
rl = 1.2
current_theme = theme_minimal() +
  theme(
    panel.border = element_rect(colour = 'black', fill = NA),
    panel.grid.minor = element_blank(),
    axis.title = element_text(size = rel(rl) * 1.1),
    axis.text = element_text(size = rel(rl)),
    plot.title = element_text(size = rel(rl)),
    strip.background = element_rect(fill = NA, colour = 'black'),
    strip.text = element_text(size = rel(rl)),
    legend.text = element_text(size = rel(rl)),
    legend.title = element_text(size = rel(rl), face = 'italic'),
    legend.position = 'bottom',
    legend.direction = 'horizontal'
  )

#automatically create a bib database for R packages
knitr::write_bib(c(
  .packages(), 'knitr', 'rmarkdown'
), 'packages.bib')
```

Introduction {#intro}
============

Cancers are a heterogeneous set of diseases with a number of clinical and pathological subtypes. In disease such as breast cancer the primary clinical classifications relate to the expression of hormone receptors (estrogen receptor: ER; and progesterone receptor: PR) or the overexpression of Erb-B2 receptor tyrosine kinase (HER2), as these features can be directly targeted with therapeutic agents. For many other cancers, subtype classification has largely relied upon identifying sets of recurrent mutations across large patient cohorts, with large whole genome or whole exome sequencing studies helping to resolve the clinically significant subtypes [@cancer13, @papaemmanuil16].

In recent years there has also been a rapid development and uptake of RNA-sequencing technologies which allow us to examine the transcriptional profile of biological samples [@cieslik18]. Through large scale efforts such as The Cancer Genome Atlas [**cite**] transcriptomic data are available for thousands of clinical samples, often together with corresponding genomic or epigenomic (often DNA methylation) data. These transcriptomic data allow a better characterisation of the functional effects from corresponding mutations, and have provided a window to study the heterogeneity which arises within different subtypes of cancer due to epigenetic and transcriptional regulatory programs which can also influence cell behaviour.

Probably need a paragraph on gene set scoring etc**

Here, we demonstrate that the single-sample gene set scoring method singscore [@foroutan18] (	<http://bioconductor.org/packages/singscore/>) can be used together with a transriptional 'gene signature' for NPM1c mutation. Without any need for parameter fitting or estimation, we show that gene set scoring for this method can identify samples carrying this mutation with very high recall.

Description of the biological problem {#biol_problem}
=====================================

As with most cancers, acute myeloid leukemia (AML) is a heterogeneous cancer with a number of classified subtypes. Analysis of TCGA AML genomic data identified a number of AML subtypes based upon the presence of absence of specific 'driver mutations' which recapitulated a number of previously identified subsets [@cancer13]. A more recent study which focussed primarily on genomic data has further refined the clinically-significant AML subtypes [@papaemmanuil16], highlighting a number of co-occurring mutations. Of note for this work, one of the most common mutations in clinical AML samples is a frameshift mutation within exon 12 of the nucleophosmin (NPM1) gene [**cite**]. This mutation leads to abberant localisation of NPM1, leading to accumulation within the cytoplasm rather than the nucleolus, and accordingly this mutation is often referred to as the NPM1c mutation [**cite**]. Furthermore, as shown by Papaemmanuil, this NPM1c mutation tends to co-occur with mutations in DNA methyltransferase 3A (DNMT3A) or internal tandem duplications within the 'Fms Related tyrosine kinase' gene (FLT3-ITD) [@papaemmanuil16].

As noted by Verhaak et al [@verhaak05], the NPM1c mutation is associated with dysregulated activity of the homeobox domain (Hox) family of transcription factors which are essential for developmental patterning [cite]. The effects of this mutation in disease progression have been further demonstrated in recent work which showed that loss of NPM1c leads to differentiation of AML cells [10.1016/j.ccell.2018.08.005]. Given this, it is interesting to note that another relatively large subset of AML samples are classified by lysine methyl transferase 2A (KMT2A; previously known as MLL) fusion genes, and these MLL fusion genes also drive dysregulated expression of Hox family genes [@hess04].

In this workflow we demonstrate the ability of the singscore method for single sample gene set scoring [@foroutan18] to classify tumour 'driver mutations' from transcriptomic data. We use a previously identified gene signature for the NPM1c mutation [@verhaak05] which is included within the molecular signatures database (mSigDB) [@liberzon15], and demonstrate that a bi-directional scoring approach can classify TCGA AML samples with the NPM1c mutation with a very high recall. While the precision of this classification is not particularly high, we show that many of the 'false positive' samples carry MLL-fusion mutations, and this classification likely arises through the shared downstream biological effects of Hox family dysregulation.


Downloading and preparing the data {#download_and_prepare}
==================================

Data from the cancer genome atlas (TCGA) project is made available through the Genomic Data Commons (GDC). Open access data from the project can be accessed in multiple pre-processed formats. Transcriptomic data can be downloaded either at the count level or as FPKM trasformed, before or after upper quantile normalisation. Other pre-processed version can be found from sources such as the [www.cbioportal.org](http://www.cbioportal.org/) and [firebrowse.org](http://firebrowse.org). The GDC data used STAR to perform a two-pass alignment followed by quantification using HTSeq. Data from the GDC can be downloaded using the [GDC data transfer tool](https://gdc.cancer.gov/access-data/gdc-data-transfer-tool) which allows users to select the specific files of interest using the GDC portal. These files then have to be read, merged, annotated and processed into a data structure that simplifies downstream analysis. Alternatively, all the above mentioned steps, including the download, can be performed using the R package `TCGAbiolinks`. The package supports data download using the GDC API and the GDC client. We will use the TCGAbiolinks package to download, annotate and process the data into a SummarizedExperiment R object.

The following steps need to be performed to prepare the data:

1. Create a query to select the files to download
2. Execute the query and download the data
3. Read the data into R
4. Filter out genes with low expression
5. Normalise the data for compositional bias and transform to account for gene-length biases

Querying the GDC database {#gdc_query}
-------------------------

The first step in any analysis should be to determine and report the version of the data and the service used to download the data. The `getGDCInfo()` function returns the release date of all data on the GDC along with a version.

```{r gdc_query}
library(TCGAbiolinks)

#get GDC version information
gdc_info = getGDCInfo()
gdc_info
```

A query then needs to be run on the GDC to identify the specific files to download. This step is similar to generating a *MANIFEST* file using the GDC portal. The first parameter of the query specifies the project whose data needs to be downloaded. Available projects can be accessed using the `getGDCprojects()` or from <https://portal.gdc.cancer.gov/projects>. The TCGA acute myeloid leukemia data is part of the TCGA-LAML project. Following this, the data category, data type and workflow type need to be specified. The query formed below selects files containing the count level transcriptomic measurements. Values for different parameters of the query can be identified from "searching arguments" section of the "query" package vignette which can be accessed using `vignette("query", package = "TCGAbiolinks")`. The results of this query will be a dataframe containing filenames and additional annotations related to the files.

Read count level data are selected instead of the processed FPKM data as one of the downstream pre-processing analysis results in filtering out of genes. A general recommendation is to compute FPKM values after filtering genes out so as to ensure counts are normalised by the correct library sizes.

```{r gdc_results}
#form a query for the RNAseq data
query_rna = GDCquery(
  #getGDCprojects()
  project = 'TCGA-LAML',
  #TCGAbiolinks:::getProjectSummary('TCGA-LAML')
  data.category = 'Transcriptome Profiling',
  data.type = 'Gene Expression Quantification',
  workflow.type = 'HTSeq - Counts'
)

#extract results of the query
rnaseq_res = getResults(query_rna)
dim(rnaseq_res)
colnames(rnaseq_res)
```

Downloading the TCGA AML RNA-seq read counts {#download_data}
--------------------------------------------

The `GDCdownload` function then executes the query on the GDC database and begins downloading the data using the GDC API. The download method should be changed to "client", if the size of the data is expected to be large. This would mostly be the case if data downloaded are reads or methylation data. It is good practice to specify the directory where the data will be stored therefore we store all the data to the "GDCdata" directory. The function downloads the data and organises it into the folder based on the parameters specified in the query. This allows multiple different levels and types of data to be stored in the same directory structure. Files with counts are stored at *./GDCdata/TCGA-LAML/harmonized/Transcriptome_Profiling/Gene_Expression_Quantification/*.

```{r gdc_download, results='hide'}
datapath = './GDCdata'
GDCdownload(query_rna, directory = datapath) #(size: 39MB)
```

Reading count-level data into R {#read_data}
-------------------------------

The `GDCprepare` function reads and processes the downloaded data into a `RangedSummarizedExperiment` object which allow patient annotations, gene annotations and count data to be stored in one object. Patient annotations are downloaded upon calling this function and subsequently mapped and attached to the resulting object. A RangedSummarizedExperiment object is similar to an ExpressionSet object but provides added functionality such as indexing with genomic coordinates and storing multiple data matrices with the same structure. Feature annotations used to annotate the data are stored in an RDA/RDATA file.

```{r gdc_prepare, results='hide'}
aml_se = GDCprepare(query_rna, directory = datapath)
```

The object contains data for 56,925 features and 151 samples. The original data files contain 60,483 features, some of which could not be mapped to GRCh38.p12 (3,767). Feature and sample annotations can be accessed using `rowData(se)` and `colData(se)` respectively and the counts data can be accessed using `assay(se)`. The TCGA data usually contains some formalin-fixed paraffin-embedded (FFPE) samples which should be discarded from the analysis as the protocol introduces biological artefacts. This procedure is only performed on solid tumours and not leukemias, therefore, no filtering is required for this data set.

```{r show_se}
aml_se
```

Filter out genes with low counts {#filter_data}
--------------------------------

The `edgeR` package contain methods that assist in data normalisation and transformation which are required for filtering and subsequent steps. The methods require a DGEList object therefore we begin by creating a DGEList for the AML data from the SummarizedExperiment. Creation of a DGEList object is initially unsuccessful due to duplicated row names in the data matrix (176 features). The raw count files for individual samples do not have any duplicated features indicating this is introduced by the `GDCprepare` function. This is further supported by the fact that the counts for a single feature are the same for duplicated entries. An example of such a feature is shown below and we have verified duplicated entries of all other features to be the same.

```{r dup_entries}
library(SummarizedExperiment)

#example check on one feature ID
dup_feature = 'ENSG00000277610'
dup_data = assay(aml_se[rownames(aml_se) %in% dup_feature, ])
identical(dup_data[1, ], dup_data[2, ])
```

As such, it is safe to discard duplicated entries.

```{r remove_dups}
library(edgeR)

aml_se = aml_se[!duplicated(rownames(aml_se)), ]
aml_dge = DGEList(counts = assay(aml_se), genes = rowData(aml_se))
```

Genes with low counts across most samples are discarded from the analysis. This is a standard step in differential expression analysis as inclusion of such genes in the analysis could skew estimates of dispersion. It is also motivated in rank-based analysis, such as with singscore, to avoid rank duplication. Rank duplication reduces the discriminant power of scores as the number of unique ranks is reduced. A commonly used filter is to select only those genes that have CPMs above a certain threshold across a proportion of samples. Filtering is performed on the CPMs rather than raw counts as the former is invariant to library sizes, therefore, unbiased. For instance, a CPM of 1 would equate to read counts between 19 and 50 for samples in the AML data where library sizes vary between 18.6 and 49.7 million reads. Here, we retain genes that have a CPM > 1 across more than 50% of the samples. Other methods to filter out genes with low counts exists and may be preferable in specific applications. @chen16 and @law16 filter genes based on the experimental design whereby the proportion of samples with enough read counts are evaluated per experimental group. As the AML data have many samples and lack rare groups, filtering is performed across all samples rather than within groups. Group specific filtering would be recommended if the study of interest would be focused on rare groups.

```{r fig.wide=TRUE, fig.cap="Histogram of logCPM values for the AML data before and after filtering. Filtering results in fewer zeros in the data."}
prop_expressed = rowMeans(cpm(aml_dge) > 1)
keep = prop_expressed > 0.5

op = par(no.readonly = TRUE)
par(mfrow = c(1, 2))
hist(cpm(aml_dge, log = TRUE), main = 'Unfiltered', xlab = 'logCPM')
abline(v = log(1), lty = 2, col = 2)
hist(cpm(aml_dge[keep, ], log = TRUE), main = 'Filtered', xlab = 'logCPM')
abline(v = log(1), lty = 2, col = 2)
par(op)
```

```{r remove_low_counts}
#subset the data
aml_dge = aml_dge[keep, , keep.lib.sizes = FALSE]
aml_se = aml_se[keep, ]
```

Transformation to FPKM values and normalisation {#calc_fpkm}
-----------------------------------------------

Singscore requires gene expression measurements to be comparable between genes, therefore, correction for gene length biases needs to be performed. Transformations such as transcripts per million (TPM) and reads/fragments per kilobase per million (RPKM/FPKM), that normalise by gene length, may be used. Both, TPM and RPKM/FPKM values should produce similar results when applying singscore provided that the library size is large enough, which it is here. RPKM values are generally computed after correcting for compositional biases. The `calcNormFactors` function in edgeR provides three methods to do so, TMM normalisation being the default. @chen16 and @law16 discuss the implications of normalisation prior to down-stream processing. Normlisation is generally performed for cross-sample analysis where samples need to be comparable. Singscores are invariant to data normalisation as the analysis is contained within the sample of interest. The idea extends to any transformation that preserves the relative ranks of genes within a sample such as a log transformation. Here, we normalise the samples using TMM normalisation solely for visualisation purposes.

Data transformations to TPM or RPKM/FPKM require the gene lengths for all genes to be calculated. Gene lengths need to be computed based on the alignment and quantification parameters. The TCGA transcriptomic data has been aligned using STAR and quantified using HTSeq (details of the pipeline available at <https://docs.gdc.cancer.gov/Data/Bioinformatics_Pipelines/Expression_mRNA_Pipeline/>). HTSeq quantifies reads mapping to the exons of each gene, therefore, effective gene lengths can be calculated as the sum of all exons spanning the gene. The GENCODE v22 annotation file was used for quantification therefore the same file needs to be used to compute gene lengths.

```{r download_gencode, results='hide'}
#download v22 of the GENCODE annotation
gencode_file = 'gencode.v22.annotation.gtf.gz'
gencode_link = paste(
  'ftp://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_human/release_22',
  gencode_file,
  sep = '/'
  )
download.file(gencode_link, gencode_file, method = 'libcurl') #(size: 39MB)
```

The `rtracklayer` R package provides functions to help parse GTF files.

```{r compute_gene_lengths}
library(rtracklayer)
library(plyr)

gtf = import.gff(gencode_file, format = 'gtf', genome = 'GRCm38.71', feature.type = 'exon')
#split records by gene to group exons of the same gene
grl = reduce(split(gtf, elementMetadata(gtf)$gene_id))
gene_lengths = ldply(grl, function(x) {
  #sum up the length of individual exons
	return(c('gene_length' = sum(width(x))))
}, .id = 'ensembl_gene_id')
```

Genes are also annotated with their biotype for further analysis. The annotation file uses Ensembl IDs with versions as keys to records, which then need to be converted to Ensembl IDs. This is simply achieved by concatenating the trailing version number.

```{r add_biotype}
#extract information on gene biotype
genetype = unique(elementMetadata(gtf)[, c('gene_id', 'gene_type')])
colnames(genetype)[1] = 'ensembl_gene_id'
gene_lengths = merge(genetype, gene_lengths)

#remove ENSEMBL ID version numbers
gene_lengths$ensembl_gene_id = gsub('\\.[0-9]*', '', gene_lengths$ensembl_gene_id)
saveRDS(gene_lengths, file = 'gene_lengths_HTSeq_gencodev22.rds')
gene_lengths
```

The SummarizedExperiment object allows feature annotations to be stored, therefore, information on gene length and biotypes should be added to the existing annotations. Similarly, annotations need to be added to the DGEList object with the column name consisiting the word "length".

```{r add_length_annotation}
#allocate rownames for ease of indexing
rownames(gene_lengths) = gene_lengths$ensembl_gene_id
rowData(aml_se)$gene_length = gene_lengths[rownames(aml_se), 'gene_length']
rowData(aml_se)$gene_biotype = gene_lengths[rownames(aml_se), 'gene_type']

#annotate gene lengths for the DGE object
aml_dge$genes$length = gene_lengths[rownames(aml_dge), 'gene_length']
```

RPKM/FPKM values can now be calculated with the computed gene lengths after computing the normalisation factors. The SummarizedExperiment object can store multiple levels of the data simultaneously, provided that the number of features and samples remains the same across measurements. As such, FPKM values are appended to the existing object. All three normalisation methods will be performed and their resulting FPKM values stored in the SummarizedExperiment object. This will allow comparison of the signature scores computed from all three processing methods simultaneously.

```{r compute_fpkm}
aml_dge_tmm = calcNormFactors(aml_dge, method = 'TMM')

#compute FPKM values and append to assays
assay(aml_se, 'logFPKM_TMM') = rpkm(aml_dge_tmm, log = TRUE)
aml_se
```

Annotate samples with mutation data {#annotate_mutations}
-----------------------------------

Original file at <https://tcga-data.nci.nih.gov/docs/publications/aml_2012/SupplementalTable01.xlsx>

```{r preproc_mutations, eval=FALSE, include=FALSE}
#preprocessing - read tsv (Joe's version) and convert save as RDS
mut_info = read.csv('PatientMutations.tsv', sep = '\t', colClasses = c('character', rep('logical', 8)))
rownames(mut_info) = mut_info$Barcode
mut_info = mut_info[, -1]
patients = mut_info[substring(colnames(aml_se), 1, 12), ]
rownames(patients) = colnames(aml_se)
saveRDS(patients, file = 'AMLPatientMutationsTCGA.rds')
```

```{r annotate_mutations}
patient_mutations = readRDS('AMLPatientMutationsTCGA.rds')
aml_mutations = colnames(patient_mutations)
colData(aml_se) = cbind(colData(aml_se), patient_mutations)
colData(aml_se)[, aml_mutations]
```

Map Ensembl IDs to Entrez IDs {#map_gene_ids}
-----------------------------

RefSeq annotations (Entrez IDs) may be more suited to RNA-seq analysis which requires a stable reference annotation to align against [@wu13]. In contrast, Ensembl annotations (Ensembl IDs) have higher coverage of the genome which may be useful in applications such as variant calling and similar exploratory analysis [@zhao15]. As such, we choose to map Ensembl IDs to Entrez IDs and discard any unmapped features.

Mapping can be performed using the Ensembl Biomart service which can be queried using the biomaRt bioconductor package. This would provide the most up to date annotations. Alternatively, mapping could be performed with the bi-annually updated `org.Hs.eg.db` annotation R package which provides a stable set of annotations, thereby enhancing reproducibility. Mapping is performed with the `mapIds` function in the `AnnotationDbi` R package.

```{r map_ensembl_entrez}
library(org.Hs.eg.db)

rowData(aml_se)$entrezgene = mapIds(
  org.Hs.eg.db,
  keys = rownames(aml_se),
  keytype = 'ENSEMBL',
  column = 'ENTREZID',
  multiVals = 'asNA'
  )
gene_annot = rowData(aml_se)
```

Multimapped Ensembl IDs are replaced by `NAs`, then discarded to enforce unique mapping. Similarly, Entrez IDs that map to multiple Ensembl IDs are identified from the mapping, and discarded. Only features with unique Ensembl ID and Entrez ID mappings remain.

```{r discard_multimapped_genes}
#select genes with mapped Entrez IDs
keep = !is.na(gene_annot$entrezgene)

#select genes with unique Entrez IDs
dup_entrez = gene_annot$entrezgene[duplicated(gene_annot$entrezgene)]
keep = keep & !gene_annot$entrezgene %in% dup_entrez

#Biotype of genes discarded due to non-unique mapping
head(sort(table(gene_annot[!keep, 'gene_biotype']), decreasing = TRUE), n = 10)

#subset the data
aml_se = aml_se[keep, ]
```

Transcriptional signatures to predict mutation status {#transcriptional_mut_sig}
=====================================================

The signature by @verhaak05 is now used to predict the mutation status of the NPM1c mutation. This is done by quantifying the concordance of genes in the signature with their expression in each sample. As such, high expression of up-regulated genes and low expression of down-regulated genes would result in higher scores. This single value can then be used to predict the mutation status of individual samples.

The signatures of interest are first downloaded from the MSigDB and read into `GeneSet` objects from the `GSEABase` R package. We then use the `singscore` R/Bioconductor package to quantify each sample for the Verhaak signature. Some of the visualisation and diagnostic tools within the `singscore` package are used to interpret the signatures and scores. Finally, we use a simple logistic regression model on the scores to predict the mutation status.

Download signature and load into R {#prepare_signature}
----------------------------------

The @verhaak05 signature is composed of an up-regulated and a down-regulated gene set. Many signatures are developed in such a manner to improve discrimination of samples. MSigDB stores such signatures using names with suffixes "_UP" and "_DN" representing the independent components of the signature. Here, we form the download links for the signature with the base name "VERHAAK_AML_WITH_NPM1_MUTATED".

```{r signature_names}
#create signature names
verhaak_names = paste('VERHAAK_AML_WITH_NPM1_MUTATED', c('UP', 'DN'), sep = '_')
verhaak_names
```

The signatures are then downloaded using the links, resulting in an XML file for each component of the signature. The `mapply` function is used to run the download function on all pairs of link-output arguments.

```{r download_signatures, results='hide'}
#generate URLs
verhaak_links = paste0(
  'http://software.broadinstitute.org/gsea/msigdb/download_geneset.jsp?geneSetName=',
  verhaak_names,
  '&fileType=xml'
  )

#download files
verhaak_files = paste0(verhaak_names, '.xml')
mapply(download.file, verhaak_links, verhaak_files, method = 'libcurl')
```

Functions in the `GSEABase` package help in reading, parsing and processing the signatures. Signatures from an MSigDB XML file can be read using the `getBroadSets` function which results in a `GeneSet` object. Gene symbols, Entrez IDs and affymetrix chip IDs from the original experiment (HG-U133A in this case) are stored in the XML file. Entrez IDs are read from the file as these can be mapped directly to our data. Conversions to other identifiers can be achieved using `mapIdentifiers` package from `GSEABase` and an annotation package that contains the mappings. The advantage of using this function instead of the `mapIds` function from the `AnnotationDb` package is that the former retains the `GeneSet` object after conversion of IDs.

```{r read_signatures}
library(GSEABase)

verhaak_sigs = getBroadSets(verhaak_files, membersId = 'MEMBERS_EZID')
verhaak_sigs
```

To ease indexing of the data when scoring using the signatures, rownames of the `SummarisedExperiment` object are changed to Entrez IDs which are already part of the row annotations.

```{r rows_to_entrez}
rownames(aml_se) = rowData(aml_se)$entrezgene
```

Score TCGA AML samples using the Verhaak signature {#score_samples}
--------------------------------------------------

Compute ranks of each gene sample-wise which are then used to compute scores. We want to do this for each type of normalised data therefore we will be using the `endoapply` function from the `S4Vectors` R/bioconductor package which retains the structure of the data.

```{r compute_ranks_aml}
library(singscore)

#apply the rankGenes method to each version of the dataset, excluding counts
aml_ranked = rankGenes(assay(aml_se, 'logFPKM_TMM'))
```

Three possible modes of using singscore:

1. Single signature with known direction (e.g. up-regulated genes)
2. Single signature with unknown direction (e.g. mixture up- and down-regulated genes without specific annotation)
2. Two signatures with known direction (e.g. a separate signature exists for up- and down-regulated genes)

The third mode is suitable for this application. The median absolute deviation is the default choice of a dispersion measure as it is non-parametric. All other signature scoring methods only report the score of a signature (which is usually some estimate of the expectation of expression) and ignore the variance of expression. Both measurements are required to fully characterise a score therefore singscore reports both.

```{r compute_scores_verhaak, warning=TRUE}
#apply the scoring function
verhaak_scores = simpleScore(aml_ranked,
                             upSet = verhaak_sigs[[1]],
                             downSet = verhaak_sigs[[2]])

head(verhaak_scores)
```

Diagnostics of the Verhaak signature {#diagnostics_verhaak}
------------------------------------

The `singscore` package provides a set of visualisation tools that enable diagnostics of the gene signature. For instance, these tools may be used to determine the importance of each signature of a dual signature (up- and down-regulated genes) to the total score, determine the importance of each gene of a signature in discriminating between the classes of interest and to look at the relationship between the final score and the dispersion of ranks. Annotations of interest can be overlayed on each plot. We begin by investigating the relationship between the score and dispersion of ranks of expression for the up-regulated gene signature, down-regulated gene signature and the full signature.

```{r fig.wide=TRUE, fig.cap="Total scores, scores for up-regulated genes, and scores for down-regulated genes for all samples. Scores are plot agains the median absolute deviation of the ranks of genes in each signature.", fig.height=4}
#create annotation
mutated_gene = rep('Other', ncol(aml_se))
mutated_gene[aml_se$NPM1.Mut] = 'NPM1 Mut'
mutated_gene[aml_se$KMT2A.Fusion | aml_se$KMT2A.PTD] = 'MLL Fusion/PTD'
p1 = plotDispersion(verhaak_scores, annot = mutated_gene)

#overwrite the colour palette and some elements of the theme
p1 + scale_colour_brewer(palette = 'Dark2') +
  theme(
    legend.text = element_text(size = rel(rl)),
    legend.title = element_text(size = rel(rl), face = 'italic')
  )
```

Here we see that the signature of down-regulated genes has more discriminant power in separating the NPM1 mutated samples and those without. Moreover, the signature is able to discriminate MLL fusions and PTDs from the other samples. NPM1 mutations result in produce higher scores for the down-regulated gene set while MLL fusions and PTDs produce moderate scores. Similar trends are observed with the set of up-regulated genes, however, despite the range of scores increasing, the discriminant power drops moderately. In fact, the signature of up-regulated genes is able to discriminate samples without the genomic changes of interest ('Other') better by producing negative scores for most of these samples. Negative scores for the up-regulated signature indicate that these genes are expressed below median expression, therefore, likely down-regulated. Another observation from these plots is the trend of the MAD. The MAD is generally expected to be higher for scores close to zero. Zero scoresare achieved either by having all genes expressed at median expression level, genes are evenly distributed at both ends of the expression spectrum, or, the more likely scenario whereby the rank of expression of all genes are uniformly distributed. The last two scenarios would result in a high dispersion. To explain these ideas, we select 3 samples and plot the ranks of genes in both signatures. The sample with the highest total score, lowest total score and highest dispersion (MAD) are chosen.

```{r fig.wide=TRUE, fig.cap="Rank distribution of genes in the Verhaak signature for 3 samples. The barcode plot for ranks of genes in each signature along with the density of the ranks is shown in each plot. Up-regulated genes are represented in green and down-regulated in purple", fig.height=4}
library(gridExtra)

#select samples with the properties required
select_samples = c(
  'Max Total Score' = which.max(verhaak_scores$TotalScore),
  'Min Total Score' = which.min(verhaak_scores$TotalScore),
  'Max Dispersion' = which.max(verhaak_scores$TotalDispersion)
  )

#plotRankDensity applied to each sample
rank_plots = lapply(names(select_samples), function(x) {
  #get the sample index
  aml_sample = select_samples[x]
  #drop = FALSE is required to ensure the data.frame is intact
  p1 = plotRankDensity(rankData = aml_ranked[, aml_sample, drop = FALSE],
                       upSet = verhaak_sigs[[1]],
                       downSet = verhaak_sigs[[2]])
  
  #overwrite title of the plot with the description of the sample
  p1 = p1 + ggtitle(paste(x,  mutated_gene[aml_sample], sep = '\n')) +
    scale_colour_brewer(palette = 'Accent') +
    theme(legend.title = element_blank())
  return(p1)
})

#create a multipanel plot
grid.arrange(grobs = rank_plots, nrow = 1)
```

This figure shows that both the up- and down-regulated genesets contribute to the score of the top scoring sample as these genes are at the extremes ends of the rank spectrum. Similarly, the lowest scoring sample has the ranks of genes in each set inverted. As observed in the previous plot, the up-regulated genes improve the discrimination between NPM1 mutated samples and other samples and may be a stronger indicator of wild-type NPM1 samples than the down-regulated genes. Finally, the sample with the maximum dispersion exhibits uniformly distributed down-regulated gene ranks and a bimodal distribution of the up-regulated gene ranks with the modes at the extremes of the spectrum.

Combined, these plots show that both the up- and down-regulated genes play an important role in discriminating between NPM1 mutated (and MLL fusion/PTD samples), and wild-type samples. These diagnostic plots help in determining the importance of genes in signatures with respect to the samples of interest and should be used prior to application of signatures. Many signatures have been developed in specific contexts due to inherent biases in datasets and yet been described in a generalised setting (Sep paper ref?). These diagnostic plots may help in validating their application in specific contexts and possibly assist in characterising the contexts of all existing signatures.

Predicting mutations using the Verhaak signature {#predict_verhaak}
------------------------------------------------

Results in non-parametric model, scores are non-parametric, invariant to most transformations. Not the case if the genes in the signature are used directly in the model.

The Verhaak transcriptomic signature can be used to predict the presence of specific mutations.

Create a `data.frame` to store the data required for modelling

```{r}
#create a dataframe with the data required: scores and mutations
scoredf = as.data.frame(colData(aml_se)[, aml_mutations])
scoredf$Score = verhaak_scores$TotalScore
scoredf$Dispersion = verhaak_scores$TotalDispersion
```

Boxplot to visualise the predictive capacity of scores for the different mutations

```{r fig.wide=TRUE, fig.height=4.5, fig.cap="Boxplot of scores from the Verhaak signature split by different types of mutations."}
#restructure the data for ploting
plotdf = melt(
  scoredf,
  id.var = c('Score', 'Dispersion'),
  variable.name = 'Mutation',
  value.name = 'Status'
  )
#convert TRUE-FALSE values to Mut-WT
plotdf$Status = factor(plotdf$Status, labels = c('WT', 'Mut'))
p1 = ggplot(plotdf, aes(Mutation, Score, fill = Status)) +
  geom_boxplot(position = 'dodge', alpha = 0.6) +
  scale_fill_brewer(palette = 'Set2') +
  current_theme
p1
```

Use independent GLMs to predict mutations based on scores

```{r predict_mutation_glm}
#fit GLMs to each mutation
glms = lapply(aml_mutations, function(x) {
  #generate a formula for the fit
  form = as.formula(paste0(x, ' ~ Score'))
  glm1 = glm(form, data = scoredf, family = binomial(link = 'logit'))
  return(glm1)
})
names(glms) = aml_mutations

#extract coefficients
coefs = lapply(glms, function(x) coef(summary(x)))
ldply(coefs, function(x) x[2, ], .id = 'Mutation')
```

NPM1 mutations are significantly associated with the score. So are DNMT3A and FLT3 mutations, and MLL Fusions. Explain with respect to the coefficient estimates in GLMs.

Evaluate prediction model performance {#prediction_performance}
-------------------------------------

```{r eval_prediction_performance}
library(caret)

#assess sensitivity and specificity
sens_spec = ldply(glms, function(glm1) {
  #predict mutations for the data used in training and convert to binary format
  prediction = as.numeric(predict(glm1) > 0)
  prediction = as.factor(prediction)
  truth = as.factor(glm1$y)
  
  #compute the sensitivity and specificity using the caret package
  sens = sensitivity(prediction, truth)
  spec = specificity(prediction, truth)
  return(c('Sensitivity' = sens, 'Specificity' = spec))
}, .id = 'Mutation')
sens_spec
```

Including the dispersion estimates in the model may improve predictions

```{r predict_with_mads}
#include dispersion in the model
glm_npm1 = glm('NPM1.Mut ~ Score + Dispersion',
               data = scoredf,
               family = binomial(link = 'logit'))

#evaluate performance of the new model
prediction = as.numeric(predict(glm_npm1) > 0)
prediction = as.factor(prediction)
truth = as.factor(glm_npm1$y)
c(
  'Sensitivity' = sensitivity(prediction, truth),
  'Specificity' = specificity(prediction, truth)
  )
```

Regulatory signatures to predict protein phosporylation {#pheno_phospho_sig}
=======================================================

Download and process the CCLE data {#download_ccle}
----------------------------------

Use CCLE cell line data from the PharmacoGx package. Package represents data in PharmacoSets (PSets). PSets store molecular measurements such as gene expression (RNA-seq), mutation profiles and copy number variation along with drug sensitivy measurements. We are only interested in the expression measurements

```{r download_ccle_pset}
library(PharmacoGx)

ccle_pset = downloadPSet("CCLE") #(size: 246MB)
```


Score samples using the E2F1 over-expression signature {#score_e2f1}
------------------------------------------------------

Transcriptomic gene signatures representing the trascriptional changes resulting from over-expression of the E2F1 transcription factor are downloaded and processed as described in the previous section.

```{r process_e2f1_sigs}
#create signature names
e2f1_names = paste('RB_DN.V1', c('UP', 'DN'), sep = '_')
#generate URLs
e2f1_links = paste0(
  'http://software.broadinstitute.org/gsea/msigdb/download_geneset.jsp?geneSetName=',
  e2f1_names,
  '&fileType=xml'
  )

#download files
e2f1_files = paste0(e2f1_names, '.xml')
mapply(download.file, e2f1_links, e2f1_files, method = 'libcurl')
e2f1_sigs = getBroadSets(e2f1_files, membersId = 'MEMBERS_EZID')
```

AML samples are then scored using the new signature. Ranks computed in \@ref(score_samples) can be reused to compute scores with the new signature.

```{r score_e2f1}
e2f1_scores = simpleScore(aml_ranked,
                          upSet = e2f1_sigs[[1]],
                          downSet = e2f1_sigs[[2]])
```

E2F1_UP vs. Verhaak signature landscape {#sig_landscape}
---------------------------------------

```{r fig.small = TRUE, fig.cap="Signature landscape. ", fig.height=4}
p1 = plotScoreLandscape(
  verhaak_scores,
  e2f1_scores,
  scorenames = c('VERHAAK_AML_WITH_NPM1_MUTATED', 'E2F1_UP')
  )
#we modify the number of bins in the landscape to ensure they are not too sparse
p1$layers[[1]]$stat_params$bins = round(sqrt(ncol(aml_se)))

#project NPM1 mutations onto the landscape
p2 = projectScoreLandscape(p1,
                           verhaak_scores,
                           e2f1_scores,
                           subSamples = aml_se$PML.RARA)
p2
```


Packages used {.unnumbered}
=============

This workflow depends on various packages from version `r BiocManager::version()` of the Bioconductor project, running on `r version$version.string` or higher. The complete list of the packages used for this workflow are shown below:

```{r session_info}
sessionInfo()
```

Additional analysis {.unnumbered}
===================


References {.unnumbered}
==========